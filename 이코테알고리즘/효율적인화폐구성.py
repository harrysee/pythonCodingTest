# 다이나믹 프로그래밍
# N가지 종류의 화폐가 있다. 화폐 개수를 최소한 이용하여 가치의 합이 M원이 되도록
# 각 종류 화폐는 몇개든 사용 가능
# ex) 2원, 3원 단위 화폐 있을 시 15원을 만들기 위해 3원 5개 사용이 최소한
# 입력: 첫줄(N,M) / 둘째줄부터 (화폐가치)

# 풀이 아이디어
# 각 화폐단위만큼 보텀업으로 최소화폐개수를 저장하는 DP테이블을 만드는게 어떨까
# 존재하지 않는 경우는 INF로 넣기
# 1. 모든 배열 INF로 초기화 = 조건이 M <=10000 이기에 10001이 INF임
# 2. 각 DP 배열인덱스를 만들기 위한 화폐단위 최소개수를 채운다.
    # 제공된 화폐단위를 for문돌려서 확인한다. -> min(해당인덱스값, (해당인덱스-화폐단위)값 +1) -> 존재안하면 INF로 채워질듯
    # 위에서 +1한 이유 : 해당 화폐단위로 뺏을때 최적해와 현재화폐단위 개수1을 포함시켜서 비교
# 3. 주어진 화폐단위 M까지 반복하며 마지막 M의 최적해 개수를 출력

N,M = map(int,input().split())
wons = []
dp = [10001]*(M+1)
for i in range(N):
    wons.append(int(input()))

dp[0] = 0   # 0일 때는 더 이상 빼지지않음
for i in range(M):
    for w in wons:
        if dp[i-w]!=10001:
            dp[i] = min(dp[i], dp[i-w]+1)

if dp[M-1] >= 10001:
    print(-1)
else:
    print(dp[M-1])  # 만들고자 하는 곳의 최적해 출력

# 다이나믹 프로그램 새로 알게 된 용어정리
# DP 테이블 : 최적해를 각각 찾은 결과들을 담는 배열
# 도식화 : 그림으로 그리거나 표현해보기
# 점화식 : 인접한 항들 사이의 관계식을 의미
# 보텀업 : 반복문으로 작을 걸 모아서 큰걸만듬
# 탑다운 : 재귀로 큰걸 작게 쪼갬